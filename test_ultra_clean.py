#!/usr/bin/env python3
"""
Test ultra-aggressive text cleaning for Telegram
"""

def ultra_clean_telegram_text(text):
    """Ultra-aggressive cleaning to prevent ANY Telegram parsing errors"""
    if not text:
        return "Analysis complete"
    
    # Convert to string and get basic content
    clean_text = str(text)
    
    # Remove ALL potentially problematic characters
    problematic_chars = ['*', '_', '`', '[', ']', '(', ')', '{', '}', 
                       '<', '>', '|', '\\', '/', '~', '^', 
                       '&', '%', '$', '#', '@', '!', '+', '=']
    
    for char in problematic_chars:
        clean_text = clean_text.replace(char, ' ')
    
    # Replace multiple spaces with single space
    while '  ' in clean_text:
        clean_text = clean_text.replace('  ', ' ')
    
    # Remove any remaining special unicode characters
    clean_text = ''.join(c for c in clean_text if ord(c) < 128 or c.isalnum() or c in ' .,:-\n')
    
    # Split into lines and clean each
    lines = clean_text.split('\n')
    cleaned_lines = []
    
    for line in lines:
        line = line.strip()
        if line and len(line) > 0:
            # Keep only safe characters
            safe_line = ''.join(c for c in line if c.isalnum() or c in ' .,:-')
            if safe_line.strip():
                cleaned_lines.append(safe_line.strip())
    
    # Rebuild message with safe content only
    result = '\n'.join(cleaned_lines)
    
    # Limit length
    if len(result) > 3500:
        result = result[:3500] + "\n\nMessage truncated for safety"
    
    return result.strip()

def create_simple_message(signal_type, confidence, next_time, total_candles):
    """Create the simplest possible Telegram message"""
    
    simple_msg = f"""GHOST TRANSCENDENCE CORE CANDLE WHISPERER

SIGNAL: {signal_type}
TIMEFRAME: 1M
ENTRY TIME: {next_time} UTC+6
CONFIDENCE: {confidence}%

CANDLE CONVERSATIONS: {total_candles} candles consulted

FEATURES ACTIVE:
- Candle Whisperer Mode
- 100% Accuracy Target
- UTC+6 Timing Precision
- Secret Pattern Detection
- Loss Prevention System

This signal was generated by talking with every candle for maximum accuracy."""
    
    return simple_msg

def test_problematic_texts():
    """Test ultra-cleaning on the most problematic text scenarios"""
    
    print("üß™ TESTING ULTRA-AGGRESSIVE TEXT CLEANING")
    print("=" * 50)
    
    # Most problematic text samples that could break Telegram
    test_cases = [
        # Case 1: Complex AI reasoning with special chars
        """CANDLE WHISPERER: ALL CANDLES AGREE: NEXT CANDLE GOES DOWN! 8 candles voting PUT | PROPHECY: ALL CANDLES AGREE: NEXT CANDLE GOES DOWN! 8 candles voting PUT | üïØÔ∏è CONSULTED 19 CANDLES | VOTES: 3.5 CALL, 7.5 PUT | PROPHECY: ALL CANDLES AGREE: NEXT CANDLE GOES DOWN! 8 candles voting PUT | üéØ HIGH ACCURACY SIGNAL (105%) | FEATURES: Candle Conversations, Secret Patterns, Time Precision, Loss Learning""",
        
        # Case 2: Unicode emojis and special characters
        """üî• GHOST TRANSCENDENCE CORE ‚àû vX - CANDLE WHISPERER\n\nüïØÔ∏è SIGNAL: PUT\n‚è∞ TIMEFRAME: 1M\nüéØ ENTRY TIME: 02:22 (UTC+6:00)\nüìà CONFIDENCE: 1.1%\nüé™ ACCURACY: 99.0%""",
        
        # Case 3: Mixed formatting characters
        """Analysis: *Strong* _bullish_ `pattern` [confirmed] {breakout} <chart> |confidence| @high #level $value %rate \\escape /slash""",
        
        # Case 4: Very long text
        "Very long message with repeating content. " * 200,
        
        # Case 5: Edge case characters
        """Test: ~tilde ^caret &ampersand !exclamation +plus =equals (parentheses) [brackets] {braces} <angles> |pipes| \\backslash /forward""",
    ]
    
    for i, test_text in enumerate(test_cases, 1):
        print(f"\nüìã TEST CASE {i}:")
        print(f"Original length: {len(test_text)} chars")
        print(f"Preview: {test_text[:100]}...")
        
        # Apply ultra-cleaning
        try:
            cleaned = ultra_clean_telegram_text(test_text)
            print(f"‚úÖ Cleaned length: {len(cleaned)} chars")
            print(f"Cleaned preview: {cleaned[:100]}...")
            
            # Check for any remaining problematic characters
            problematic_found = []
            problematic_chars = ['*', '_', '`', '[', ']', '(', ')', '{', '}', 
                               '<', '>', '|', '\\', '/', '~', '^', 
                               '&', '%', '$', '#', '@', '!', '+', '=']
            
            for char in problematic_chars:
                if char in cleaned:
                    problematic_found.append(char)
            
            if problematic_found:
                print(f"‚ö†Ô∏è  Still found: {problematic_found}")
            else:
                print("‚úÖ Completely clean!")
                
        except Exception as e:
            print(f"‚ùå Cleaning failed: {e}")
        
        print("-" * 30)
    
    # Test simple message creation
    print(f"\nüì± TESTING SIMPLE MESSAGE FORMAT:")
    simple_msg = create_simple_message("CALL", 85.5, "14:25", 20)
    print(f"Length: {len(simple_msg)} chars")
    print("Content:")
    print(simple_msg)
    
    # Check simple message for problems
    problematic_found = []
    problematic_chars = ['*', '_', '`', '[', ']', '(', ')', '{', '}', 
                       '<', '>', '|', '\\', '/', '~', '^', 
                       '&', '%', '$', '#', '@', '!', '+', '=']
    
    for char in problematic_chars:
        if char in simple_msg:
            problematic_found.append(char)
    
    if problematic_found:
        print(f"‚ö†Ô∏è  Simple message has issues: {problematic_found}")
    else:
        print("‚úÖ Simple message is completely safe!")

if __name__ == "__main__":
    test_problematic_texts()
    print("\nüéâ ULTRA-CLEANING TEST COMPLETE!")
    print("üì± Telegram bot should now handle ANY text without parsing errors!")